---
title: "Exploratory Data Analysis" 
author: "Anusha Kumar, Kyla Finlayson, Nataliya Kyrychenko"
output:
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)

#Load packages
library(tidyverse)
library(kableExtra)
library(gridExtra)
library(tableone)
library(lubridate)
library(anytime)
library(gridExtra)
library(stringr)
library(gtsummary)
library(gt)
library(usmap)
library(zoo)

#Read in data
isolates <- read.csv("~/Desktop/isolates.csv", na.strings=c("","NA"))
```

### **Data Description**

In this study, secondary data is used for Campylobacter jejuni, taken from the "Isolates" browser of the National Library of Medicine's (NIH) NCBI Pathogen Detection Project.

This public repository is widely used by public health practitioners and researchers, both at international, federal, and state levels. It helps to match foodborne pathogens that became source of clinical cases around the US, and even the whole world through clustering of related isolates. It also helps to investigate outbreaks, research prevalence of strains, AMR and virulence genes. There are other types of use of NCBI Pathogen Detection database both by public health practitioners and researchers. For example, the database is used for international outbreaks investigation, connecting clinical and environmental isolates in Canada, USA, France, Australia, and South Korea. Except outbreak detection, the database is used for analysis of distribution of pathogens throughout the world, including specific virulent genes, AMR-resistant genes, analysis of prevalence of certain genomic sequence.

For our project, we will be using a specific subset of the databse which contains isolates of Campylobacter jejuni. Our initial dataset has 80095 observations, 19 variables, and can be located at:
https://www.ncbi.nlm.nih.gov/pathogens/isolates/#taxgroup_name:%22Campylobacter%20jejuni%22. The default dataset has 16 main variables, with the option to add other variables. We have decided to add three variables: 'Collection.date', "Outbreak', and 'Host disease' as we believe these could potentially be useful in our analysis.

### **Data Overview**

First, we will look at our variable definitions and decide which variables we will be keeping to use in our analysis.

```{r}

data.overview <- data.frame(Variables = c("X.Organism.group", "Strain", "Isolate.identifiers", "Serovar",
                                          "Isolate", "Create.date", "Location", "Isolation.source",
                                          "Isolation.type", "SNP.cluster", "Min.same", "Min.diff",
                                          "BioSample", "Assembly", "AMR.genotypes", "Computed.types",
                                          "Collection.date", "Host.disease", "Outbreak"),
                            Descriptions = c("A categorical character variable, with only one level-- 'Campylobacter jejuni'. This variable shows the group in which an organism is classified into by taxonomy.",
                                             "A categorical character variable that represents the subtype or genetic variation of a microorganism (in our case, of Campylobacter jejuni).",
                                             "A categorical character variable that represents a list of alternative identifiers that an isolate may be known by.",
                                             "A categorical character variable that represents the combined field of sub-species, serotype, or serovar, if provided.",
                                             "A categorical character variable that srepresents the Pathogen Detection Project's accession of the isolate, in other words, a unique identifier for each isolate.",
                                             "A time variable that represents the date and time that each isolate was entered or created in the Pathogen Detection database.",
                                             "A categorical character variable that represents the location where the data was collected (geographic location of the sample). This variable includes country, or country and state.",
                                             "A categorical character variable that represents the source of each isolate (where the isolate was extracted from).",
                                             "A categorical character variable that represents the type of isolation in each observation (clinical OR environmental/other). Isolates sampled from humans will be clinical, and isolates sampled from animals/meat/the environment be environmental/other.",
                                             "A categorical character variable that represents single nucleotide polymorphisms (SNP) clusters. More specifically, an SNP cluster is a group of isolates, where the genome assemblies are closely linked to each other.",
                                             "A continuous variable that represents the minimum SNP distance from one isolate to another of the same isolation type. ",
                                             "A continuous variable that represents the minimum SNP distance from one isolate to another of a different isolation type.",
                                             "A categorical character variables that represents the accession number (unique identifier) for each biosample. All identifiers will be unique unless there are two strains collected from the same biosample.",
                                             "A categorical character variable that represents the accession number (unique identifier) for the genome sequence of the isolate from the Assembly database.",
                                             "A categorical character variable that represents the antimicrobial resistance (AMR) genes found in each isolate. These AMR genes are linked to or implicated in the resistance to one or more antibiotics.",
                                             "A variable that represents the 'computational prediction based on the sequence calculated'. It is unclear what type of variable this would be, all values are empty because it's only available for Salmonella isolates.",
                                             "A time variable that represents the date that each isolate was collected from its respective sample.",
                                             "A categorical character variable that represents the disease that the host of the sample is presenting with, if applicable.",
                                             "A categorical character variable that represents the identifier for an outbreak that an isolate is tied to."))

data.overview %>%
  kbl() %>%
  kable_styling(latex_options = c("hold_position", "scale_down"), 
                font_size = 6) %>%
  add_header_above(c("Table 1: Variable Definitions"=2)) %>%
  column_spec(2, width = "45em")
```

The first variable we will be removing is *X.Organism.group*. This variable has the same value, "Campylobacter jejuni" for each of our isolates, thus it is not useful. We will also be removing *Serovar*, as this variable is missing for 99.5% of our observations and will not provide us with much information. Next, we will be removing *BioSample*-- almost all 80,000 values are unique except for 9 and we already have a unique identifier for isolates. We will also be removing the variable *Assembly* because again, almost all 80,000 values are unique and does not seem like it will be very useful in our analysis. Next, we will be removing *Computed.types* because all values are NA in our dataset. Next, we will be removing *Host.disease* because approximately 85% of our values are missing, and for the values that are not missing, the large majority of values are "campylobacteriosis", "campylobacter enteritis", or some other variation of the same diagnosis. Lastly, we will also be removing *Outbreak* because almost all 80,000 of our values are NA, except for 7. Another variable we may consider removing in the future is *Isolate.identifiers*. This variable contains other identifiers that the isolate may be known by in other databases, for example in the Biosample database, so this information may not be valuable. However, we will keep it in our dataset for now.

```{r}
isolates <- isolates %>%
  select(-c(X.Organism.group, Serovar, BioSample, Assembly, Computed.types,
            Host.disease, Outbreak))
```

### **Data Cleaning**

Before we begin exploring our data, there are a few variables we would like to create. After conducting a brief initial exploration of our data, there were a few variables that require cleaning and/or regrouping. 

We first noticed that one of our variables of interest, *Collection.date*, usually contains the year of collection but is often missing the month and/or the day of isolate collection. As a result, we will create a two new variables called *Year* and *Month* which contain the collection year and month, respectively, when it is available. When collection year is not available, it will use the creation year (when it is uploaded into the data base). The same applies for month as well. From our exploration, we saw that creation date is usually relatively close to collection date, however, our variable will be more accurate if we utilize the correct information that we do have. We will use these two variables as our time variables for analysis rather than using *Collection.date* or *Create.date*.

```{r}
# Year

  # Convert all dates to the same Y-M-D format, those that do not have
  # years will return as NA and we can fill in year from Create.date
isolates$Collection.date2 <- anydate(isolates$Collection.date)

  # Parse the year
isolates$Year <- format(as.Date(isolates$Collection.date2, 
                                format = "%Y-%m-%d"), "%Y")

  # Fill in NA values with year from Create.date
isolates$Year <- ifelse(is.na(isolates$Year),
                        format(as.Date(isolates$Create.date), "%Y"),
                        isolates$Year)

# Month

  # Convert all dates to the same Y-M format, those that do not have
  # months will return as NA and we can fill in month from Create.date
isolates$Collection.date2 <- ym(isolates$Collection.date)

  # Parse the month
isolates$Month <- format(as.Date(isolates$Collection.date2,
                                 format = "%Y-%m-%d"), "%m")

  # Fill in NA values with month from Create.date
isolates$Month <- ifelse(is.na(isolates$Month),
                        format(as.Date(isolates$Create.date), "%m"),
                        isolates$Month)

# Remove Create.date and Collection.date, as they are no longer needed
isolates <- isolates %>%
  select(-c(Create.date, Collection.date, Collection.date2))
```

Next, we noticed that another one of our variables of interest, *Isolation.source*, is very messy. Because this variable is sourced from text input, each category has many different variations based on terms used, capitalization, punctuation, etc. For example, "Raw chicken meat", "chicken wings", and "young chickens" all have the same meaning, that the isolate is from chicken, but they are considered different categories. There are a total of 657 different categories in our data for this variable. As a result, we are going to look at the most frequently used words in *Isolation.source* and create a new variable called *Source* with condensed categories based on our key terms. 

```{r, eval=FALSE}
  # First, we will need to remove all punctuation and make all letters
  # lowercase
isolates$Isolation.source <- isolates$Isolation.source %>%
  str_to_lower() %>%
  str_replace_all("[:punct:]", " ")

  # Now we will split each entry into its respective words and look
  # at the most frequently used terms
sort(table(unlist(strsplit(isolates$Isolation.source, " "))), decreasing=TRUE)
```

Some of our most frequently used keywords include "chicken", "animal", "raw", "stool", "carcass", "cattle" and "human". Using these, our variable *Isolation.type* (which can help to differentiate human cases because type will be clinical), and our general knowledge of Campylobacter sources, we can regroup this variable to include the most common isolation sources, and have a bucket for the unusual/less common ones called "Other". We will not distinguish between animal meat and live animals for our sources, because our text mining will likely be more inaccurate and both sources are likely to have the same effect on human outbreaks.

```{r}

isolates <- isolates %>%
  mutate(Source = case_when(str_detect(Isolation.source, "gallus") |
                              str_detect(Isolation.source, "chicken") | 
                              str_detect(Isolation.source, "chickens") |
                              str_detect(Isolation.source, "poultry") |
                              str_detect(Isolation.source, "wings") |
                              str_detect(Isolation.source, "breasts") |
                              str_detect(Isolation.source, "legs") |
                              str_detect(Isolation.source, "gizzard") |
                              str_detect(Isolation.source, "gizzards") |
                              str_detect(Isolation.source, "thighs") ~ "Chicken",
                            str_detect(Isolation.source, "cattle") |
                              str_detect(Isolation.source, "bull") |
                              str_detect(Isolation.source, "cow") |
                              str_detect(Isolation.source, "cows") |
                              str_detect(Isolation.source, "bovine") |
                              str_detect(Isolation.source, "ovine") |
                              str_detect(Isolation.source, "steer") |
                              str_detect(Isolation.source, "veal") |
                              str_detect(Isolation.source, "calf") |
                              str_detect(Isolation.source, "heifer") |
                              str_detect(Isolation.source, "taurus") |
                              str_detect(Isolation.source, "beef") ~ "Cattle",
                            str_detect(Isolation.source, "dairy") |
                              str_detect(Isolation.source, "cream")~ "Dairy",
                            str_detect(Isolation.source, "pig") |
                              str_detect(Isolation.source, "swine") |
                              str_detect(Isolation.source, "pork") ~ "Pig",
                            str_detect(Isolation.source, "turkey") |
                              str_detect(Isolation.source, "sponge") ~ "Turkey",
                            str_detect(Isolation.source, "human") |
                              str_detect(Isolation.source, "clinical") |
                              (str_detect(Isolation.source, "stool") &
                                 isolates$Isolation.type == "clinical") |
                              (str_detect(Isolation.source, "feces") &
                                 isolates$Isolation.type == "clinical")|
                              (is.na(Isolation.source) == TRUE &
                                 isolates$Isolation.type == "clinical") ~ "Human",
                            is.na(Isolation.source) == TRUE ~ Isolation.source,
                            TRUE ~ "Other"))

# Remove Isolation.source, as we will be using Source instead
isolates <- isolates %>%
  select(-Isolation.source)
```

Next, we will apply our inclusion/exclusion criteria. For this project, we will be focusing in on cases in the United States from 2012-2020. We originally planned to include data from the last decade, but we only have information on outbreaks in the US up to 2020. Therefore, we will narrow down our dataset according to these criteria. Afterwards, we will change our *Location* variable into a variable called *State*, which will just include the state the isolate was collected from, otherwise NA.

```{r}
# Inclusion / Exclusion Criteria

# Filter to years 2012 and later, and filter to within the US
isolates <- isolates %>%
  filter(Year >= 2012 & Year <= 2020) %>%
  filter(grepl("USA", Location)) # 43,089
```

```{r}
# State

#   Since all are in the same format, we can parse the letters that come 
#   after the colon (:) in "USA:"
isolates$State <- str_match(isolates$Location, ":(.+)")[,-1]

#   Cleaning values that are not in two-letter state format
isolates$State[isolates$State == " California"] <- "CA"
isolates$State[isolates$State == " Berkeley California"] <- "CA"
isolates$State[isolates$State == " Oxnard, CA"] <- "CA"
isolates$State[isolates$State == " Florida"] <- "FL"
isolates$State[isolates$State == " Georgia"] <- "GA"
isolates$State[isolates$State == " Georgia (State)"] <- "GA"
isolates$State[isolates$State == " Maywood, IL"] <- "IL"
isolates$State[isolates$State == " Michigan"] <- "MI"
isolates$State[isolates$State == " New York"] <- "NY"
isolates$State[isolates$State == " North Carolina"] <- "NC"
isolates$State[isolates$State == "North Carolina"] <- "NC"
isolates$State[isolates$State == " Seattle, WA"] <- "WA"
isolates$State[isolates$State == " Pennsylvania"] <- "PA"
isolates$State[isolates$State == " Slaughter Beach, DE"] <- "DE"
isolates$State[isolates$State == " Philadelphia"] <- "PA"
isolates$State[isolates$State == " Wyndmoor, PA"] <- "PA"
isolates$State[isolates$State == " Wyndmoor, Pennsylvania"] <- "PA"
isolates$State[isolates$State == "Boston"] <- "MA"
isolates$State[isolates$State == "CA-Contra Costa"] <- "CA"
isolates$State[isolates$State == "Lubbock"] <- "TX"
isolates$State[isolates$State == "Mississippi"] <- "MS"
isolates$State[isolates$State == "TN-Knoxville"] <- "TN"
isolates$State[isolates$State == "TN-Nashville"] <- "TN"
isolates$State[isolates$State == "States"] <- NA

# Remove spaces, if any
isolates$State <- gsub(" ", "", isolates$State)

# Remove Location variable as it is no longer needed
isolates <- isolates %>%
  select(-Location)
```

Lastly, we want to create our outcome of interest, *Outbreak*. Because the "Outbreak" variable that came with our dataset is more than 99% missing, we have to create it from scratch. We considered creating it using variables in our dataset, but it would be pointless to create our outcome from explanatory variables and then regress our outcome on the explanatory variables. Only about 10% of our isolates are sampled from humans, the remainder are mostly from animals or animal meat. However, animals and animal meat outbreaks are a direct cause of human outbreaks because they are our food sources. We will be using data on Campylobacter jejuni outbreaks in the US from 2012-2020 to create our variable. In this dataset, we have data on the state, month, and year for all 592 Campylobacter jejuni outbreaks that occurred in the US from 2012-2020. If there are samples in the same exact time and state as an outbreak as recorded by the CDC, they are likely linked. As a result, our variable *Outbreak* will be equal to 1 if the isolate seems to be linked to an outbreak, of any kind, and will be equal to 0 otherwise. 

```{r}
outbreaks <- read.csv("~/Desktop/NationalOutbreakPublicDataTool.csv")

# Change "State" variable to the format that matches State in our isolates data
outbreaks$State[outbreaks$State == "Alabama"] <- "AL"
outbreaks$State[outbreaks$State == "Alaska"] <- "AK"
outbreaks$State[outbreaks$State == "Arizona"] <- "AZ"
outbreaks$State[outbreaks$State == "Arkansas"] <- "AK"
outbreaks$State[outbreaks$State == "California"] <- "CA"
outbreaks$State[outbreaks$State == "Colorado"] <- "CO"
outbreaks$State[outbreaks$State == "Connecticut"] <- "CT"
outbreaks$State[outbreaks$State == "Florida"] <- "FL"
outbreaks$State[outbreaks$State == "Georgia"] <- "GA"
outbreaks$State[outbreaks$State == "Idaho"] <- "ID"
outbreaks$State[outbreaks$State == "Illinois"] <- "IL"
outbreaks$State[outbreaks$State == "Indiana"] <- "IN"
outbreaks$State[outbreaks$State == "Iowa"] <- "IA"
outbreaks$State[outbreaks$State == "Kansas"] <- "KS"
outbreaks$State[outbreaks$State == "Kentucky"] <- "KY"
outbreaks$State[outbreaks$State == "Maryland"] <- "MD"
outbreaks$State[outbreaks$State == "Massachusetts"] <- "MA"
outbreaks$State[outbreaks$State == "Michigan"] <- "MI"
outbreaks$State[outbreaks$State == "Minnesota"] <- "MN"
outbreaks$State[outbreaks$State == "Missouri"] <- "MO"
outbreaks$State[outbreaks$State == "Montana"] <- "MT"
outbreaks$State[outbreaks$State == "Nebraska"] <- "NE"
outbreaks$State[outbreaks$State == "Nevada"] <- "NV"
outbreaks$State[outbreaks$State == "New Hampshire"] <- "NH"
outbreaks$State[outbreaks$State == "New Jersey"] <- "NJ"
outbreaks$State[outbreaks$State == "New York"] <- "NY"
outbreaks$State[outbreaks$State == "North Carolina"] <- "NC"
outbreaks$State[outbreaks$State == "North Dakota"] <- "ND"
outbreaks$State[outbreaks$State == "Ohio"] <- "OH"
outbreaks$State[outbreaks$State == "Oregon"] <- "OR"
outbreaks$State[outbreaks$State == "Pennsylvania"] <- "PA"
outbreaks$State[outbreaks$State == "Puerto Rico"] <- "PR"
outbreaks$State[outbreaks$State == "Rhode Island"] <- "RI"
outbreaks$State[outbreaks$State == "South Carolina"] <- "SC"
outbreaks$State[outbreaks$State == "South Dakota"] <- "SD"
outbreaks$State[outbreaks$State == "Tennessee"] <- "TN"
outbreaks$State[outbreaks$State == "Texas"] <- "TX"
outbreaks$State[outbreaks$State == "Utah"] <- "UT"
outbreaks$State[outbreaks$State == "Vermont"] <- "VT"
outbreaks$State[outbreaks$State == "Virginia"] <- "VA"
outbreaks$State[outbreaks$State == "Washington"] <- "WA"
outbreaks$State[outbreaks$State == "West Virginia"] <- "WV"
outbreaks$State[outbreaks$State == "Wisconsin"] <- "WI"
outbreaks$State[outbreaks$State == "Wyoming"] <- "WY"
```

```{r, warning = FALSE}
# Parse the Year, Month, and State combinations from our CDC outbreaks data
outbreaks <- c(paste0(outbreaks$Year, outbreaks$State, outbreaks$Month))

# Create a variable that represents the Year, Month, and State combinations 
# from each of our NCBI isolates in the same format
isolates$Month <- as.numeric(isolates$Month)
isolates$match <- paste0(isolates$Year, isolates$State, isolates$Month)


isolates <- isolates %>%
  group_by(match, SNP.cluster) %>%
  mutate(maxSNP = max(Min.same)) %>%
  ungroup()

# If the Year, Month, and State combination of an isolate matches the Year,
# Month, and State combination of a Campylobacter jejuni outbreak, Outbreak
# will equal 1, otherwise it will equal 0
isolates$Outbreak <- ifelse(isolates$match %in% outbreaks &
                               isolates$maxSNP < 8, 1, 0)

# Remove the Year, Month, and State combinations we created from our final
# dataset
isolates <- isolates %>%
  select(-c(match,maxSNP))

isolates$Outbreak[is.na(isolates$Outbreak) == TRUE] <- 0
```

```{r}
# Make sure all of our created variables are in correct structure type

isolates$State <- factor(isolates$State)
isolates$Year <- factor(isolates$Year)
isolates$Month <- factor(isolates$Month)
isolates$Outbreak <- factor(isolates$Outbreak)
```

Our final dataset has 13 variables and 43,089 observations.

### **Missing Data**

```{r, echo=FALSE, warning=FALSE, fig.height=3, fig.width=7, fig.cap = "Percentage of Missing Values"}

# Removing summarise method notification
options(dplyr.summarise.inform = FALSE)

## The code below is from a code demo we went over in class and can also be
## found at https://jenslaufer.com/data/analysis/visualize_missing_values_with_ggplot.html

#Calculating the percentages of missing values by variable
missing.values <- isolates %>%
  gather(key = "key", value = "val") %>%
  mutate(isna = is.na(val)) %>%
  group_by(key) %>%
  mutate(total = n()) %>%
  group_by(key, total, isna) %>%
  summarise(num.isna = n()) %>%
  mutate(pct = num.isna / total * 100)

#Limiting to only variables that have NA values and arranging in descending order
levels <- (missing.values %>% filter(isna == T) %>%     
             arrange(desc(pct)))$key

#Plotting missing values by variable
percentage.plot <- missing.values %>%
  ggplot() +
  geom_bar(aes(x = reorder(key, desc(pct)), 
               y = pct, fill=isna), 
           stat = 'identity', alpha=0.8) +
  scale_x_discrete(limits = levels) +
  scale_fill_manual(name = "", 
                    values = c('steelblue', 'tomato3'), 
                    labels = c("Present", "Missing")) +
  coord_flip() +
  labs(x = 'Variable', y = "% of missing values")

percentage.plot
```

As we see in Figure 1, we do not have many variables with a high percentage of missing values after whittling down our dataset to variables that may be useful, and cleaning variables that we would like to use. The two variables with the highest percentages are *Min.diff* and *State*, which have 36% and 35% of their values missing, respectively. Other variables with missing values include *Min.same* which has about 18% of its values missing, *SNP.cluster* which has 16% of values missing, and *AMR.genotypes* which has 8% of values missing. The remaining variables with missing values have a negligible (less than 0.1%) percentage of missing values.

The most important variable to note here is that *State* has a moderate percentage of missing values, which is a limitation that will potentially bias our results. For an isolate to be linked to an outbreak in our data, it needs to have state nonmissing. Furthermore, we expect it to be a potential explanatory variable or variable to adjust for, so our estimate on its relationship to outbreaks or our adjustment may be biased or underestimated since we have so many missing values. The remaining variables we also expect to be potential explanatory variables or variables to adjust for, and the same applies to these. 

Next, we will look at our missing values by row to see if there are any patterns among the data and determine our missingness assumption.

```{r, echo=FALSE, warning=FALSE, fig.height=3, fig.width=7, fig.cap="Missing Values by Row"}

## The code below is from a code demo we went over in class and can also be
## found at https://jenslaufer.com/data/analysis/visualize_missing_values_with_ggplot.html

#Selecting only our continuous variables and visualizing missingness by row number
row.plot <- isolates %>%
  mutate(id = row_number()) %>%
  gather(-id, key = "key", value = "val") %>%
  mutate(isna = is.na(val)) %>%
  ggplot(aes(key, id, fill = isna)) +
  geom_raster(alpha=0.8) +
  scale_fill_manual(name = "",
                    values = c('steelblue', 'tomato3'),
                    labels = c("Present", "Missing")) +
  scale_x_discrete(limits = levels) +
  labs(x = "Variable",
       y = "Row Number") +
  coord_flip()

row.plot
```

As we see in Figure 2, observations that are missing *Min.diff* also tend to be missing *Min.same* and *SNP.cluster*. This makes sense, as these variables are all related to SNPs and will all be missing if samples do not undergo SNP genotyping. The large majority of missing values are likely for reasons that are unknown to us, therefore our data is missing not at random (MNAR). This is a large limitation to our analysis, as we may estimate biased results. In the future, the NCBI Pathogen Detection Project should consider reforming their data collection process, for example changing the submission to require most or all fields, if they would like to use the data to estimate accurate trends or predictions.

### **Univariate Exploration**












### **Multivariate Exploration**

First, we will want to see if there are any significant differences in distribution of our variables between isolates that are part of an outbreak, and isolates that are not part of an outbreak. Since many of our variables are categorical with thousands of categories, we will first examine our variables with many categories to see if there seems to be any relationship (for example, if there are a much smaller number of categories relative to the size of the Outbreak group, when compared with the non-Outbreak group). Then, we look at variables that have a small number of categories and see if there is a significant difference in proportions.

**Strain**

```{r, include = FALSE}
nlevels(factor(isolates$Strain[isolates$Outbreak == 0]))
nlevels(factor(isolates$Strain[isolates$Outbreak == 1]))
```

For the 1,844 isolates that are potentially linked to outbreaks, we have 1,839 unique categories for Strain. For the 41,245 isolates that are not linked to outbreaks, we have 41,165 unique categories for Strain. The majority of isolates seem to have unique strains for both outbreak-linked and non-outbreak-linked isolates, therefore, I do not see a strong relationship between these two variables.

**Isolate identifiers**

```{r, include = FALSE}
nlevels(factor(isolates$Isolate.identifiers[isolates$Outbreak == 0]))
nlevels(factor(isolates$Isolate.identifiers[isolates$Outbreak == 1]))
```

For the 1,844 isolates that are potentially linked to outbreaks, we have 1,842 unique categories for isolate identifiers. For the 41,245 isolates that are not linked to outbreaks, we have 41,227 unique categories for isolate identifiers. The majority of isolates seem to have unique isolate identifiers for both outbreak-linked and non-outbreak-linked isolates, therefore, I do not see a strong relationship between these two variables.

**SNP cluster**

```{r, include = FALSE}
nlevels(factor(isolates$SNP.cluster[isolates$Outbreak == 0]))
nlevels(factor(isolates$SNP.cluster[isolates$Outbreak == 1]))

isolates %>%
  filter(Outbreak == 0) %>%
  mutate(count = 1) %>%
  group_by(SNP.cluster) %>%
  summarise(n = sum(count)) %>%
  arrange(-n)

isolates %>%
  filter(Outbreak == 1) %>%
  mutate(count = 1) %>%
  group_by(SNP.cluster) %>%
  summarise(n = sum(count)) %>%
  arrange(-n)
```

For the 1,844 isolates that are potentially linked to outbreaks, we have 607 unique categories for SNP cluster. For the 41,245 isolates that are not linked to outbreaks, we have 3,831 unique categories for SNP cluster. In other words, 33.0% of isolates linked to outbreaks have a unique SNP cluster while 9.3% of isolates not linked to outbreaks have a unique cluster. This tells us that isolates that are linked to outbreaks may be more diverse or that less commonly seen clusters are more likely to cause an outbreak. 

Looking at the differences in the most frequently seen clusters, it appears that SNP clusters PDS000022633.154, PDS000107294.24, PDS000073565.149, and PDS000022710.12 may be more associated with outbreaks. As a result, we conclude that this variable seems to have a relationship with outbreak.

**AMR genotypes**

```{r, include=FALSE}
nlevels(factor(isolates$AMR.genotypes[isolates$Outbreak == 0]))
nlevels(factor(isolates$AMR.genotypes[isolates$Outbreak == 1]))

isolates %>%
  filter(Outbreak == 0) %>%
  mutate(count = 1) %>%
  group_by(AMR.genotypes) %>%
  summarise(n = sum(count)) %>%
  arrange(-n)

isolates %>%
  filter(Outbreak == 1) %>%
  mutate(count = 1) %>%
  group_by(AMR.genotypes) %>%
  summarise(n = sum(count)) %>%
  arrange(-n)
```

For the 1,844 isolates that are potentially linked to outbreaks, we have 203 unique categories for AMR genotypes. For the 41,245 isolates that are not linked to outbreaks, we have 1,787 unique categories for AMR genotypes. In other words, 11.0% of isolates linked to outbreaks have a unique AMR genotype while 4.3% of isolates not linked to outbreaks have a unique AMR genotype. Again, this tells us that isolates linked to outbreaks may be more genetically diverse, or that less commonly seen strains are more likely to cause an outbreak because they could be more mutated / respond worse to treatment.

Looking at the differences in the most frequently seen AMR genotypes, it appears that genotypes "aph(3')-IIIa=COMPLETE,blaOXA-193=COMPLETE,gyrA_T86I=POINT,tet(O)=COMPLETE" and "gyrA_T86I=POINT" may be more associated with outbreaks. As a result, we conclude that this variable seems to have a relationship with outbreak. In the future, it may be useful to parse each of these AMR genotypes (since it is formatted in a list) and create multiple binary variables for whether or not each isolate has them.

**State**

```{r, fig.height = 3, fig.width = 7, fig.cap = "Overall Cases per State stratified by Outbreak", warning = FALSE}

# Outbreak = 0
    # Create data frame with one column of states and another column of counts
outbreak0states <- isolates %>%
  filter(Outbreak == 0) %>% 
  mutate(count = 1) %>%
  group_by(State) %>%
  summarise(n = sum(count))

colnames(outbreak0states) <- c("state","values")

    # Plot number of cases per state on a heat map
f1 <- plot_usmap(data = na.omit(outbreak0states),
           values = "values",
           color = "black") +
  scale_fill_continuous(low = "white", 
                        high = "orange", 
                        name = "Cases",
                        label = scales::comma) + 
  theme(legend.position = "right") +
  labs(title = "Cases not linked to an Outbreak")



# Outbreak = 1
    # Create data frame with one column of states and another column of counts
outbreak1states <- isolates %>%
  filter(Outbreak == 1) %>% 
  mutate(count = 1) %>%
  group_by(State) %>%
  summarise(n = sum(count))

colnames(outbreak1states) <- c("state","values")

    # Plot number of cases per state on a heat map
f2 <- plot_usmap(data = na.omit(outbreak1states),
           values = "values",
           color = "black") +
  scale_fill_continuous(low = "white", 
                        high = "orange", 
                        name = "Cases",
                        label = scales::comma) + 
  theme(legend.position = "right") +
  labs(title = "Cases linked to an Outbreak")

  # Display maps side by side
grid.arrange(f1, f2, nrow = 1)
```
As we see from the map on the right in Figure 3, cases that are linked to an outbreak seem to be highly associated with the states of Texas and Pennsylvania, compared to the general population of isolates that are not linked to an outbreak / isolated cases. Isolated cases (where there are not more than 1 from the same source), seem to be highly prevalent in Georgia, California, Texas, Arkansas, and North Carolina as we can see from the map on the left in Figure 3. In general, this pattern makes because we know that incidence of Campylobacter jejuni is linked to warmer climates. However, the high prevalence of outbreak cases in Pennysylvania is somewhat of an outlier. Overall, it does appear that the variable state has a relationship with outbreak.

Now, we will look at the remainder of our variables (that have a smaller number of categories) in a table and decide which to further examine.

```{r, warning = FALSE}
isolates %>%
  select(Isolation.type, Min.same, Min.diff, Year, Month, Source, Outbreak) %>%
  tbl_summary(by = Outbreak,
              type = list(where(is.numeric) ~ "continuous2", 
                          all_dichotomous() ~ "categorical"),
              statistic = list(all_continuous() ~ c("{mean} ± {sd}", 
                                                    "{median} ({min} - {max})"),
                               all_categorical() ~ "{n} ({p}%)"),
              digits = list(all_continuous() ~ 2,
                            all_categorical() ~ 2)) %>%
  add_p(test = Source ~ "chisq.test") %>%
  modify_header(label = "Table 2: Descriptive Statistic Stratified by Outbreak") %>%
  as_kable_extra(booktabs = TRUE) %>%
  kable_styling(latex_options = c("scale_down", "hold_position"), font_size = 5)
```

As we see in Table 2, *Isolation.type*, *Year*, *Month*, and *Source* all seem to have significant differences in distribution among isolates that are part of an outbreak and isolates that are not. As a result, we will further explore these relationships.

**Isolation.type**

Looking at Table 2, we see that for isolates linked to an outbreak, approximately 1.36% are clinical cases while 98.64% are environmental/other types. In contrast, approximately 37.41% of non-outbreak cases are clinical types and 62.59% are environmental/other times. This is an extremely large difference in proportions, and is statistically significant at the 0.01 level. One reason for this could be that human cases are less likely to spread human-to-human and become an outbreak, while outbreaks within food sources are much more likely to result in an outbreak. Either way, there does appear to be a strong relationship between these two variables.

**Year**

There appears to be a relationship between *Year* and *Outbreak*. While the overall distribution is relatively similar, the distributions are significantly different at the 0.01 significance level. Isolates that are linked to an outbreak tend to be more highly concentrated in 2017, 2018, and 2019. Furthermore, isolates linked to an outbreak seem to be less common in 2020 compared isolates that are not linked to an outbreak.

**Month**

There also appears to be a relationship between *Month* and *Outbreak*. Again, while the overall distribution is relatively similar, isolates that are linked to an outbreak tend to be more highly concentrated in warmer months, which include April, May, June, July, August, and September. Based on our previous research, we expected to see more cases during the summer months. However, the high percentage of cases both linked to an outbreak and not linked to an outbreak in April is somewhat unexpected. 

**Month + Year**

```{r, fig.width = 7, fig.height = 3, fig.cap = "Cases over Time stratified by Outbreak"}
# Create new Date variable that combines month and year for graphing
isolates$YearMonth <- as.yearmon(paste0(isolates$Year, "-", isolates$Month), "%Y-%m")
isolates$YearMonth <- format(as.Date(isolates$YearMonth), "%Y-%m")

ggplot(isolates, aes(x = YearMonth, 
                     y = ..density.., 
                     group = Outbreak,
                     fill = Outbreak)) +
  geom_density(alpha = 0.5) +
  scale_x_discrete(name = "Year-Month", 
                     breaks = c("2012-01", "2012-07",
                                "2013-01", "2013-07",
                                "2014-01", "2014-07",
                                "2015-01", "2015-07",
                                "2016-01", "2016-07",
                                "2017-01", "2017-07",
                                "2018-01", "2018-07",
                                "2019-01", "2019-07",
                                "2020-01", "2020-07")) +
  theme(axis.text.x = element_text(angle = 45), legend.position =  "bottom") +
  scale_fill_discrete(labels = c("Not linked to an outbreak", 
                                 "Linked to an outbreak")) +
  labs(x = "Year-Month", y = "Density (cases)", fill = "Outbreak")


```

Looking at the number of cases over time, we see that in both cohorts there are not many cases before 2015. This could be for a number of reasons, but the two most plausible ones are that either there has been a rapid increase in Campylobacter jejuni cases within the last few years, or that people have not many submitted cases to the Pathogen Detection Project database in previous years, compared to more recent years. Additionally, we see that in both cohorts there is a pattern of cases-- they spike during summer months and decrease in the winter. These spikes in cases appear to be more likely to lead to an outbreak, because the distribution of cases linked to an outbreak is even more concentrated during these summer months. The last difference we notice between the two cohorts is that there is a steep dropoff in cases linked to an outbreak beginning in 2020. It is unclear why we see this, but it could be related to the implementation of new policies/regulations for husbandry, or could potentially related to the onset of COVID-19. This is something we plan to explore more in the future.

**Source**

Lastly, looking at Table 2 we notice that the distribution in isolation source is significantly different between cases related to an outbreak and cases not related to an outbreak. The leading isolation source for cases not linked to an outbreak is humans, followed by chicken, and then followed by cattle. For cases linked to an outbreak, we see that chicken is the leading source, followed shortly by cattle, and then other. There are an extremely small percentage of human cases among isolates linked to an outbreak, similarly to what we saw in the exploration of *Isolation.type*. Again, this could be because cases are unlikely to transfer human-to-human, so most isolate samples from humans are isolated cases and isolate samples from food sources are much more likely to lead to an outbreak. Regardless, including both of these two variables may be superfluous, so in the future we may decide to choose one to use in our analysis.


### **Limitations**

1. The procedure of data collection incorporates certain biases in the dataset from the very beginning. First, only certified laboratories may submit isolates into the dataset. Second, the submission of data is not required (not mandatory) that develops a type of volunteer bias. Third, only those isolates that were sequenced may be included into the dataset. It means that clinical and environmental isolates that were not analyzed by whole genome sequence approach are missing in the dataset.

2. Confounding bias occurs because of a systematic distortion that changes the relationship between exposure and the result (outcome) due to the independent association between a factor and the exposure and outcome (Skelly, Dettori & Brodt, 2012). Frost (2018) showcases that missing confounding variables can influence cause and effect to determine the causal relationship based on a predictive model. If these factors are missing from the statistical model, these can mask or exaggerate the actual relationship between independent and dependent variables, this in turn, biases the estimated effects. He further argues that the problem only occurs in predictive models when the confounding factors are either not known or not recorded at all. In our dataset extracted from NCBI, clinical data is extremely limited. The information on severity of cases, demographic factors, hospitalization status, etc. is not available which not only limits the analysis, but also development of predictive models resulting in omitted variable or missing data bias.

3. Classification bias, also known as information bias or measurement bias, occurs when factors that can influence the outcome at hand are inadequately recorded, resulting in limitations of the dataset (Lambert, 2011). Though the dataset in principle contains the information on SNP distance between closest isolates in phylogenetic trees, access to this information for statistical analysis is very limited. The dataset contains only information on minimal distance between closest isolates but there is no possibility to check which isolates (except through phylogenetic trees that are not included into the general database). The SNP clusters are very broad, which is not very helpful for outbreak detection: though in literature it is mentioned that SNP-clusters are built in the framework of 50 SNPs, there are clusters with up to 98 SNPs distance. It would be helpful to have an option to define minimal and maximum distance between isolates in SNP clusters as for different purposes the distance may vary.

4. Missing data bias, also known as omitted variable bias, occurs when certain important information is missing from the dataset. This results in limitations with respect to conducting detailed analysis (Baur, 2022). Such omissions may be intentional or because the researcher did not pay attention to data recording. Gorelick (2006) highlights that large amounts of missing information in the data may result in biased estimates from predictive models. Missing data in many variables as well as the MNAR mechanism of missingness complicates the whole statistical analysis and requires many assumptions. For our research question the most problematic is non-availability of data regarding the outcome of interest (outbreak data). Among 80 thousand isolates only 7 were included into 2 outbreaks. The dataset does not provide any explanation of the reason for this missing data: there may be isolates involved in other outbreaks but this status is not mentioned in the dataset, or other isolates were not a part of outbreaks, or both. In addition, lack of specific location of isolates collection limits the possibility to determine relations among isolates, and does not support investigation of possible outbreak. Any inconsistently measured predictors or missing predictors may affect the overall validity of the predictive models.

5. Antimicrobial resistance (AMR) is considered a global problem in both human and veterinary domains. To figure out the magnitude of the AMR related problems and to track its evolution, multiple surveillance programs are conducted around the world (Boerlin et al., 2005). Since our dataset does not include information from non-certified laboratories, there is the likelihood that some strain or AMR genotype may be missing from the database. Consequently, assessment of diversity and distribution of all of the AMR genotypes or their strains may be difficult that may impede our understanding of AMR epidemiology.

**Sources for Limitations (used for definitions in limitations section)**

Baur, C. (2022). What is Missing Data Bias. https://www.researchsquare.com/blog/what-is-missing-data-bias

Boerlin, P., Travis, R., Gyles, C., Reid-Smith, R., Heather Lim, N., Nicholson, V., McEwen, S., Friendship, R., & Archambault, M. (2005). Antimicrobial Resistance and Virulence Genes of Escherichia coli Isolates from Swine in Ontario. Applied and Environmental Microbiology, 71(11), 6753–6761. https://doi.org/10.1128/aem.71.11.6753-6761.2005

Gorelick, M. (2006). Bias arising from missing data in predictive models. Journal of Clinical Epidemiology, 59(10), 1115–1123. https://doi.org/10.1016/j.jclinepi.2004.11.029

Frost, J. (2018, September 24). Confounding Variables Can Bias Your Results. Statistics by Jim. https://statisticsbyjim.com/regression/confounding-variables-bias/

Lambert, J. (2011). Statistics in Brief: How to Assess Bias in Clinical Studies? Clinical Orthopaedics and Related Research, 469(6), 1794–1796.  https://doi.org/10.1007/s11999-010-1538-7



