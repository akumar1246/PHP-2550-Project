---
title: "Variables Description" 
author: "Anusha Kumar, Kyla Finlayson, Nataliya Kyrychenko"
date: "2022-10-18"
output:
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)

#Load packages
library(tidyverse)
library(kableExtra)
library(gridExtra)
library(tableone)
library(lubridate)
library(anytime)
library(gridExtra)
library(stringr)

#Read in data
isolates <- read.csv("~/Desktop/isolates.csv", na.strings=c("","NA"))
```

### **Data Description**

In this study, secondary data is used for Campylobacter jejuni, taken from the "Isolates" browser of the National Library of Medicine's (NIH) NCBI Pathogen Detection Project.

This public repository is widely used by public health practitioners and researchers, both at international, federal, and state levels. It helps to match foodborne pathogens that became source of clinical cases around the US, and even the whole world through clustering of related isolates. It also helps to investigate outbreaks, research prevalence of strains, AMR and virulence genes. There are other types of use of NCBI Pathogen Detection database both by public health practitioners and researchers. For example, the database is used for international outbreaks investigation, connecting clinical and environmental isolates in Canada, USA, France, Australia, and South Korea. Except outbreak detection, the database is used for analysis of distribution of pathogens throughout the world, including specific virulent genes, AMR-resistant genes, analysis of prevalence of certain genomic sequence.

For our project, we will be using a specific subset of the databse which contains isolates of Campylobacter jejuni. Our initial dataset has 80095 observations, 19 variables, and can be located at:
https://www.ncbi.nlm.nih.gov/pathogens/isolates/#taxgroup_name:%22Campylobacter%20jejuni%22. The default dataset has 16 main variables, with the option to add other variables. We have decided to add three variables: 'Collection.date', "Outbreak', and 'Host disease' as we believe these could potentially be useful in our analysis.

### **Data Overview**

First, we will look at our variable definitions and decide which variables we will be keeping to use in our analysis.

```{r}

data.overview <- data.frame(Variables = c("X.Organism.group", "Strain", "Isolate.identifiers", "Serovar",
                                          "Isolate", "Create.date", "Location", "Isolation.source",
                                          "Isolation.type", "SNP.cluster", "Min.same", "Min.diff",
                                          "BioSample", "Assembly", "AMR.genotypes", "Computed.types",
                                          "Collection.date", "Host.disease", "Outbreak"),
                            Descriptions = c("A categorical character variable, with only one level-- 'Campylobacter jejuni'. This variable shows the group in which an organism is classified into by taxonomy.",
                                             "A categorical character variable that represents the subtype or genetic variation of a microorganism (in our case, of Campylobacter jejuni).",
                                             "A categorical character variable that represents a list of alternative identifiers that an isolate may be known by.",
                                             "A categorical character variable that represents the combined field of sub-species, serotype, or serovar, if provided.",
                                             "A categorical character variable that srepresents the Pathogen Detection Project's accession of the isolate, in other words, a unique identifier for each isolate.",
                                             "A time variable that represents the date and time that each isolate was entered or created in the Pathogen Detection database.",
                                             "A categorical character variable that represents the location where the data was collected (geographic location of the sample). This variable includes country, or country and state.",
                                             "A categorical character variable that represents the source of each isolate (where the isolate was extracted from).",
                                             "A categorical character variable that represents the type of isolation in each observation (clinical OR environmental/other). When an isolate is observed in a human/clinical case, the isolation type will be clinical. When an isolate is observed in an environmental setting, such as a water sample or animal, it will be environmental/other.",
                                             "A categorical character variable that represents single nucleotide polymorphisms (SNP) clusters. More specifically, an SNP cluster is a group of isolates, where the genome assemblies are closely linked to each other.",
                                             "A continuous variable that represents the minimum SNP distance from one isolate to another of the same isolation type. ",
                                             "A continuous variable that represents the minimum SNP distance from one isolate to another of a different isolation type.",
                                             "A categorical character variables that represents the accession number (unique identifier) for each biosample. All identifiers will be unique unless there are two strains collected from the same biosample.",
                                             "A categorical character variable that represents the accession number (unique identifier) for the genome sequence of the isolate from the Assembly database.",
                                             "A categorical character variable that represents the antimicrobial resistance (AMR) genes found in each isolate. These AMR genes are linked to or implicated in the resistance to one or more antibiotics.",
                                             "A variable that represents the 'computational prediction based on the sequence calculated as part of the Pathogen Detection Pipeline'. It is unclear what type of variable this would be, as all values are empty because it is only available for Salmonella isolates.",
                                             "A time variable that represents the date that each isolate was collected from its respective sample.",
                                             "A categorical character variable that represents the disease that the host of the sample is presenting with, if applicable.",
                                             "A categorical character variable that represents the identifier for an outbreak that an isolate is tied to."))

data.overview %>%
  kbl() %>%
  kable_styling(latex_options = c("hold_position","scale_down"), font_size = 9) %>%
  add_header_above(c("Table 1: Variable Definitions"=2))
```

The first variable we will be removing is *X.Organism.group*. This variable has the same value, "Campylobacter jejuni" for each of our isolates, thus it is not useful. We will also be removing *Serovar*, as this variable is missing for 99.5% of our observations and will not provide us with much information. Next, we will be removing *BioSample*-- almost all 80,000 values are unique except for 9 and we already have a unique identifier for isolates. We will also be removing the variable *Assembly* because again, almost all 80,000 values are unique and does not seem like it will be very useful in our analysis. Next, we will be removing *Computed.types* because all values are NA in our dataset. Next, we will be removing *Host.disease* because approximately 85% of our values are missing, and for the values that are not missing, the large majority of values are "campylobacteriosis", "campylobacter enteritis", or some other variation of the same diagnosis. Lastly, we will also be removing *Outbreak* because almost all 80,000 of our values are NA, except for 7.

```{r}
isolates <- isolates %>%
  select(-c(X.Organism.group, Serovar, BioSample, Assembly, Computed.types,
            Host.disease, Outbreak))
```

### **Data Cleaning**

Before we begin exploring our data, there are a few variables we would like to create. After conducting a brief initial exploration of our data, there were a few variables that require cleaning and/or regrouping. 

We first noticed that one of our variables of interest, *Collection.date*, usually contains the year of collection but is often missing the month and/or the day of isolate collection. As a result, we will create a two new variables called *Year* and *Month* which contain the collection year and month, respectively, when it is available. When collection year is not available, it will use the creation year (when it is uploaded into the data base). The same applies for month as well. From our exploration, we saw that creation date is usually relatively close to collection date, however, our variable will be more accurate if we utilize the correct information that we do have. We will use these two variables as our time variables for analysis rather than using *Collection.date* or *Create.date*.

```{r}
# Year

  # Convert all dates to the same Y-M-D format, those that do not have
  # years will return as NA and we can fill in year from Create.date
isolates$Collection.date2 <- anydate(isolates$Collection.date)

  # Parse the year
isolates$Year <- format(as.Date(isolates$Collection.date2, 
                                format = "%Y-%m-%d"), "%Y")

  # Fill in NA values with year from Create.date
isolates$Year <- ifelse(is.na(isolates$Year),
                        format(as.Date(isolates$Create.date), "%Y"),
                        isolates$Year)

# Month

  # Convert all dates to the same Y-M format, those that do not have
  # months will return as NA and we can fill in month from Create.date
isolates$Collection.date2 <- ym(isolates$Collection.date)

  # Parse the month
isolates$Month <- format(as.Date(isolates$Collection.date2,
                                 format = "%Y-%m-%d"), "%m")

  # Fill in NA values with month from Create.date
isolates$Month <- ifelse(is.na(isolates$Month),
                        format(as.Date(isolates$Create.date), "%m"),
                        isolates$Month)

# Remove Create.date and Collection.date, as they are no longer needed
isolates <- isolates %>%
  select(-c(Create.date, Collection.date, Collection.date2))

# Make sure both variables are structured as numeric
isolates$Year <- as.numeric(isolates$Year)
isolates$Month <- as.numeric(isolates$Month)
```

Next, we noticed that another one of our variables of interest, *Isolation.source*, is very messy. Because this variable is sourced from text input, each category has many different variations based on terms used, capitalization, punctuation, etc. For example, "Raw chicken meat", "chicken wings", and "young chickens" all have the same meaning, that the isolate is from chicken, but they are considered different categories. There are a total of 657 different categories in our data for this variable. As a result, we are going to look at the most frequently used words in *Isolation.source* and create a new variable called *Source* with condensed categories based on our key terms. 

```{r, eval=FALSE}
  # First, we will need to remove all punctuation and make all letters
  # lowercase
isolates$Isolation.source <- isolates$Isolation.source %>%
  str_to_lower() %>%
  str_replace_all("[:punct:]", " ")

  # Now we will split each entry into its respective words and look
  # at the most frequently used terms
sort(table(unlist(strsplit(isolates$Isolation.source, " "))), decreasing=TRUE)
```

Some of our most frequently used keywords include "chicken", "animal", "raw", "stool", "carcass", "cattle" and "human". Using these, our variable *Isolation.type* (which can help to differentiate human cases because type will be clinical), and our general knowledge of Campylobacter sources, we can regroup this variable to include the most common isolation sources, and have a bucket for the unusual/less common ones called "Other".

```{r}

isolates <- isolates %>%
  mutate(Source = case_when(str_detect(Isolation.source, "gallus") |
                                      str_detect(Isolation.source, "chicken") | 
                                      str_detect(Isolation.source, "chickens") |
                                      str_detect(Isolation.source, "poultry") |
                                      str_detect(Isolation.source, "wings") |
                                      str_detect(Isolation.source, "breasts") |
                                      str_detect(Isolation.source, "legs") |
                                      str_detect(Isolation.source, "gizzard") |
                                      str_detect(Isolation.source, "gizzards") |
                                      str_detect(Isolation.source, "thighs") ~ "Chicken",
                                      str_detect(Isolation.source, "cattle") |
                                      str_detect(Isolation.source, "bull") |
                                      str_detect(Isolation.source, "cow") |
                                      str_detect(Isolation.source, "cows") |
                                      str_detect(Isolation.source, "bovine") |
                                      str_detect(Isolation.source, "ovine") |
                                      str_detect(Isolation.source, "steer") |
                                      str_detect(Isolation.source, "veal") |
                                      str_detect(Isolation.source, "calf") |
                                      str_detect(Isolation.source, "heifer") |
                                      str_detect(Isolation.source, "dairy") |
                                      str_detect(Isolation.source, "taurus") |
                                      str_detect(Isolation.source, "cream") |
                                      str_detect(Isolation.source, "beef") ~ "Cattle",
                                      str_detect(Isolation.source, "pig") |
                                      str_detect(Isolation.source, "swine") |
                                      str_detect(Isolation.source, "pork") ~ "Pig",
                                      str_detect(Isolation.source, "turkey") |
                                      str_detect(Isolation.source, "sponge") ~ "Turkey",
                                      str_detect(Isolation.source, "human") |
                                      str_detect(Isolation.source, "clinical") |
                                      (str_detect(Isolation.source, "stool") &
                                      isolates$Isolation.type == "clinical") |
                                      (str_detect(Isolation.source, "feces") &
                                      isolates$Isolation.type == "clinical") ~ "Human",
                                      is.na(Isolation.source) == TRUE ~ Isolation.source,
                                      TRUE ~ "Other"))

# Remove Isolation.source, as we will be using Source instead
isolates <- isolates %>%
  select(-Isolation.source)
```

Next, we will apply our inclusion/exclusion criteria. For this project, we will be focusing in on cases in the United States within the last decade. Therefore, we will narrow down our dataset according to these criteria. Afterwards, we will change our *Location* variable into a variable called *State*, which will just include the state the isolate was collected from, otherwise NA.

```{r}
# Inclusion / Exclusion Criteria

# Filter to years 2012 and later, and filter to within the US
isolates <- isolates %>%
  filter(Year >= 2012 & Year <= 2020) %>%
  filter(grepl("USA", Location)) # 43,089
```

```{r}
# State

#   Since all are in the same format, we can parse the letters that come 
#   after the colon (:) in "USA:"
isolates$State <- str_match(isolates$Location, ":(.+)")[,-1]

#   Cleaning values that are not in two-letter state format
isolates$State[isolates$State == " California"] <- "CA"
isolates$State[isolates$State == " Berkeley California"] <- "CA"
isolates$State[isolates$State == " Oxnard, CA"] <- "CA"
isolates$State[isolates$State == " Florida"] <- "FL"
isolates$State[isolates$State == " Georgia"] <- "GA"
isolates$State[isolates$State == " Georgia (State)"] <- "GA"
isolates$State[isolates$State == " Maywood, IL"] <- "IL"
isolates$State[isolates$State == " Michigan"] <- "MI"
isolates$State[isolates$State == " New York"] <- "NY"
isolates$State[isolates$State == " North Carolina"] <- "NC"
isolates$State[isolates$State == "North Carolina"] <- "NC"
isolates$State[isolates$State == " Seattle, WA"] <- "WA"
isolates$State[isolates$State == " Pennsylvania"] <- "PA"
isolates$State[isolates$State == " Slaughter Beach, DE"] <- "DE"
isolates$State[isolates$State == " Philadelphia"] <- "PA"
isolates$State[isolates$State == " Wyndmoor, PA"] <- "PA"
isolates$State[isolates$State == " Wyndmoor, Pennsylvania"] <- "PA"
isolates$State[isolates$State == "Boston"] <- "MA"
isolates$State[isolates$State == "CA-Contra Costa"] <- "CA"
isolates$State[isolates$State == "Lubbock"] <- "TX"
isolates$State[isolates$State == "Mississippi"] <- "MS"
isolates$State[isolates$State == "TN-Knoxville"] <- "TN"
isolates$State[isolates$State == "TN-Nashville"] <- "TN"
isolates$State[isolates$State == "States"] <- NA
```

Lastly, we want to create our outcome of interest, *Outbreak*. Because the "Outbreak" variable that came with our dataset is more than 99% missing, we have to create it from scratch. As we know, approximately less than 1% of human Campylobacter cases are caused by an outbreak. However, we should also clarify that we are looking for outbreaks among humans as well as outbreaks among animals. Animal outbreaks are likely more common because they are in close proximity to each other, have the same food and water sources, and the same general environment. Only about 10% of our isolates are sampled from humans, and animal outbreaks are a direct cause of human outbreaks because they are our food sources. As a result, our variable *Outbreak* will be equal to 1 if the isolate seems to be part of a larger outbreak, human or animal, and will be equal to 0 otherwise.

(Option 1) For a group of isolates to qualify as an outbreak, they must have the same SNP cluster, AMR genotype, and occur in the same state and year. Furthermore, they must have an SNP distance of less than 7, have more than 2 cases occurring (as defined by the CDC), and must all occur within a timeframe of 2 months.

```{r, echo=FALSE}

outbreaks <- isolates %>%
  mutate(count = 1) %>%
  group_by(Year, State, SNP.cluster, AMR.genotypes) %>%
  mutate(cases = sum(count), 
         month_range = (max(Month) - min(Month)),
         max_SNP_dist = max(Min.same)) %>%
  filter(max_SNP_dist < 7,
         cases >= 2, 
         month_range < 2)

outbreaks <- c(outbreaks$Isolate)
isolates$Outbreak1 <- ifelse(isolates$Isolate %in% outbreaks, 1, 0)
```

(Option 2) For a group of isolates to qualify as an outbreak, they must have the same month, year, state, SNP cluster, and AMR genotype. Furthermore, the number of cases experienced for that particular state/month must be greater than the average number of cases for that state/month plus two standard deviations, and there must at least 2 cases.

```{r}
outbreaks2 <- isolates %>%
  mutate(count = 1) %>%
  filter(!is.na(State)) %>%
  group_by(Month, Year, State, SNP.cluster, AMR.genotypes) %>%
  mutate(cases_per_month = sum(count)) %>%
  ungroup() %>%
  group_by(Month, State) %>%
  mutate(avg_cases = mean(cases_per_month), sd_cases = sd(cases_per_month)) %>%
  ungroup() %>%
  group_by(Month, Year, State, SNP.cluster, AMR.genotypes) %>%
  mutate(Outbreak = ifelse((cases_per_month > (avg_cases + 2*sd_cases)) & 
                             cases_per_month >= 2, 1, 0)) %>%
  filter(Outbreak == 1)

outbreaks2 <- c(outbreaks2$Isolate)
isolates$Outbreak2 <- ifelse(isolates$Isolate %in% outbreaks2, 1, 0)
```

```{r}
outbreaks <- read.csv("~/Desktop/NationalOutbreakPublicDataTool.csv")

outbreaks$State[outbreaks$State == "Alabama"] <- "AL"
outbreaks$State[outbreaks$State == "Alaska"] <- "AK"
outbreaks$State[outbreaks$State == "Arizona"] <- "AZ"
outbreaks$State[outbreaks$State == "Arkansas"] <- "AK"
outbreaks$State[outbreaks$State == "California"] <- "CA"
outbreaks$State[outbreaks$State == "Colorado"] <- "CO"
outbreaks$State[outbreaks$State == "Connecticut"] <- "CT"
outbreaks$State[outbreaks$State == "Florida"] <- "FL"
outbreaks$State[outbreaks$State == "Georgia"] <- "GA"
outbreaks$State[outbreaks$State == "Idaho"] <- "ID"
outbreaks$State[outbreaks$State == "Illinois"] <- "IL"
outbreaks$State[outbreaks$State == "Indiana"] <- "IN"
outbreaks$State[outbreaks$State == "Iowa"] <- "IA"
outbreaks$State[outbreaks$State == "Kansas"] <- "KS"
outbreaks$State[outbreaks$State == "Kentucky"] <- "KY"
outbreaks$State[outbreaks$State == "Maryland"] <- "MD"
outbreaks$State[outbreaks$State == "Massachusetts"] <- "MA"
outbreaks$State[outbreaks$State == "Michigan"] <- "MI"
outbreaks$State[outbreaks$State == "Minnesota"] <- "MN"
outbreaks$State[outbreaks$State == "Missouri"] <- "MO"
outbreaks$State[outbreaks$State == "Montana"] <- "MT"
outbreaks$State[outbreaks$State == "Nebraska"] <- "NE"
outbreaks$State[outbreaks$State == "Nevada"] <- "NV"
outbreaks$State[outbreaks$State == "New Hampshire"] <- "NH"
outbreaks$State[outbreaks$State == "New Jersey"] <- "NJ"
outbreaks$State[outbreaks$State == "New York"] <- "NY"
outbreaks$State[outbreaks$State == "North Carolina"] <- "NC"
outbreaks$State[outbreaks$State == "North Dakota"] <- "ND"
outbreaks$State[outbreaks$State == "Ohio"] <- "OH"
outbreaks$State[outbreaks$State == "Oregon"] <- "OR"
outbreaks$State[outbreaks$State == "Pennsylvania"] <- "PA"
outbreaks$State[outbreaks$State == "Puerto Rico"] <- "PR"
outbreaks$State[outbreaks$State == "Rhode Island"] <- "RI"
outbreaks$State[outbreaks$State == "South Carolina"] <- "SC"
outbreaks$State[outbreaks$State == "South Dakota"] <- "SD"
outbreaks$State[outbreaks$State == "Tennessee"] <- "TN"
outbreaks$State[outbreaks$State == "Texas"] <- "TX"
outbreaks$State[outbreaks$State == "Utah"] <- "UT"
outbreaks$State[outbreaks$State == "Vermont"] <- "VT"
outbreaks$State[outbreaks$State == "Virginia"] <- "VA"
outbreaks$State[outbreaks$State == "Washington"] <- "WA"
outbreaks$State[outbreaks$State == "West Virginia"] <- "WV"
outbreaks$State[outbreaks$State == "Wisconsin"] <- "WI"
outbreaks$State[outbreaks$State == "Wyoming"] <- "WY"
```

```{r}
outbreaks <- c(paste0(outbreaks$Year, outbreaks$State, outbreaks$Month))
isolates$match <- paste0(isolates$Year, isolates$State, isolates$Month)

isolates$Outbreak3 <- ifelse(isolates$match %in% outbreaks, 1, 0)

isolates <- isolates %>%
  select(-match)
```

Our final dataset has 14 variables and 43,089 observations.

### **Missing Data**

```{r, echo=FALSE, warning=FALSE, fig.height=3, fig.width=7, fig.cap = "Percentage of Missing Values"}

## The code below is from a code demo we went over in class and can also be
## found at https://jenslaufer.com/data/analysis/visualize_missing_values_with_ggplot.html

#Calculating the percentages of missing values by variable
missing.values <- isolates %>%
  gather(key = "key", value = "val") %>%
  mutate(isna = is.na(val)) %>%
  group_by(key) %>%
  mutate(total = n()) %>%
  group_by(key, total, isna) %>%
  summarise(num.isna = n()) %>%
  mutate(pct = num.isna / total * 100)

#Limiting to only variables that have NA values and arranging in descending order
levels <- (missing.values %>% filter(isna == T) %>%     
             arrange(desc(pct)))$key

#Plotting missing values by variable
percentage.plot <- missing.values %>%
  ggplot() +
  geom_bar(aes(x = reorder(key, desc(pct)), 
               y = pct, fill=isna), 
           stat = 'identity', alpha=0.8) +
  scale_x_discrete(limits = levels) +
  scale_fill_manual(name = "", 
                    values = c('steelblue', 'tomato3'), 
                    labels = c("Present", "Missing")) +
  coord_flip() +
  labs(x = 'Variable', y = "% of missing values")

percentage.plot
```


```{r, echo=FALSE, warning=FALSE, fig.height=3, fig.width=7, fig.cap="Missing Values by Row"}

## The code below is from a code demo we went over in class and can also be
## found at https://jenslaufer.com/data/analysis/visualize_missing_values_with_ggplot.html

#Selecting only our continuous variables and visualizing missingness by row number
row.plot <- isolates %>%
  mutate(id = row_number()) %>%
  gather(-id, key = "key", value = "val") %>%
  mutate(isna = is.na(val)) %>%
  ggplot(aes(key, id, fill = isna)) +
  geom_raster(alpha=0.8) +
  scale_fill_manual(name = "",
                    values = c('steelblue', 'tomato3'),
                    labels = c("Present", "Missing")) +
  scale_x_discrete(limits = levels) +
  labs(x = "Variable",
       y = "Row Number") +
  coord_flip()

row.plot
```

```{r}
isolates <- isolates %>%
  select(-c()) %>%
  filter(grepl("USA", Location)) %>%
  filter(Year >= 2012)
```



